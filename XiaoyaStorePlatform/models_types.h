
//------------------------------------------------------------------------------
// This code was generated by a tool.
//
//   Tool : Bond Compiler 0.10.1.0
//   File : models_types.h
//
// Changes to this file may cause incorrect behavior and will be lost when
// the code is regenerated.
// <auto-generated />
//------------------------------------------------------------------------------

#pragma once

#include <bond/core/bond_version.h>

#if BOND_VERSION < 0x0700
#error This file was generated by a newer version of the Bond compiler and is incompatible with your version of the Bond library.
#endif

#if BOND_MIN_CODEGEN_VERSION > 0x0a10
#error This file was generated by an older version of the Bond compiler and is incompatible with your version of the Bond library.
#endif

#include <bond/core/config.h>
#include <bond/core/containers.h>



namespace XiaoyaStore
{
namespace Model
{
    
    struct UrlFrontierItem
    {
        std::string Url;
        uint64_t PlannedTime;
        uint64_t Priority;
        uint32_t FailedTimes;
        uint64_t UrlFileId;
        uint64_t UpdatedAt;
        uint64_t CreatedAt;
        
        UrlFrontierItem()
          : PlannedTime(),
            Priority(),
            FailedTimes(),
            UrlFileId(),
            UpdatedAt(),
            CreatedAt()
        {
        }

        
#ifndef BOND_NO_CXX11_DEFAULTED_FUNCTIONS
        // Compiler generated copy ctor OK
        UrlFrontierItem(const UrlFrontierItem&) = default;
#endif
        
#if !defined(BOND_NO_CXX11_DEFAULTED_MOVE_CTOR)
        UrlFrontierItem(UrlFrontierItem&&) = default;
#elif !defined(BOND_NO_CXX11_RVALUE_REFERENCES)
        UrlFrontierItem(UrlFrontierItem&& other)
          : Url(std::move(other.Url)),
            PlannedTime(std::move(other.PlannedTime)),
            Priority(std::move(other.Priority)),
            FailedTimes(std::move(other.FailedTimes)),
            UrlFileId(std::move(other.UrlFileId)),
            UpdatedAt(std::move(other.UpdatedAt)),
            CreatedAt(std::move(other.CreatedAt))
        {
        }
#endif
        
        
#ifndef BOND_NO_CXX11_DEFAULTED_FUNCTIONS
        // Compiler generated operator= OK
        UrlFrontierItem& operator=(const UrlFrontierItem&) = default;
#endif

        bool operator==(const UrlFrontierItem& other) const
        {
            return true
                && (Url == other.Url)
                && (PlannedTime == other.PlannedTime)
                && (Priority == other.Priority)
                && (FailedTimes == other.FailedTimes)
                && (UrlFileId == other.UrlFileId)
                && (UpdatedAt == other.UpdatedAt)
                && (CreatedAt == other.CreatedAt);
        }

        bool operator!=(const UrlFrontierItem& other) const
        {
            return !(*this == other);
        }

        void swap(UrlFrontierItem& other)
        {
            using std::swap;
            swap(Url, other.Url);
            swap(PlannedTime, other.PlannedTime);
            swap(Priority, other.Priority);
            swap(FailedTimes, other.FailedTimes);
            swap(UrlFileId, other.UrlFileId);
            swap(UpdatedAt, other.UpdatedAt);
            swap(CreatedAt, other.CreatedAt);
        }

        struct Schema;

    protected:
        void InitMetadata(const char*, const char*)
        {
        }
    };

    inline void swap(::XiaoyaStore::Model::UrlFrontierItem& left, ::XiaoyaStore::Model::UrlFrontierItem& right)
    {
        left.swap(right);
    }

    
    struct PostingList
    {
        std::string Word;
        uint64_t WordFrequency;
        uint64_t DocumentFrequency;
        std::set<uint64_t> Postings;
        bool IsAdd;
        
        PostingList()
          : WordFrequency(),
            DocumentFrequency(),
            IsAdd(true)
        {
        }

        
#ifndef BOND_NO_CXX11_DEFAULTED_FUNCTIONS
        // Compiler generated copy ctor OK
        PostingList(const PostingList&) = default;
#endif
        
#if !defined(BOND_NO_CXX11_DEFAULTED_MOVE_CTOR)
        PostingList(PostingList&&) = default;
#elif !defined(BOND_NO_CXX11_RVALUE_REFERENCES)
        PostingList(PostingList&& other)
          : Word(std::move(other.Word)),
            WordFrequency(std::move(other.WordFrequency)),
            DocumentFrequency(std::move(other.DocumentFrequency)),
            Postings(std::move(other.Postings)),
            IsAdd(std::move(other.IsAdd))
        {
        }
#endif
        
        
#ifndef BOND_NO_CXX11_DEFAULTED_FUNCTIONS
        // Compiler generated operator= OK
        PostingList& operator=(const PostingList&) = default;
#endif

        bool operator==(const PostingList& other) const
        {
            return true
                && (Word == other.Word)
                && (WordFrequency == other.WordFrequency)
                && (DocumentFrequency == other.DocumentFrequency)
                && (Postings == other.Postings)
                && (IsAdd == other.IsAdd);
        }

        bool operator!=(const PostingList& other) const
        {
            return !(*this == other);
        }

        void swap(PostingList& other)
        {
            using std::swap;
            swap(Word, other.Word);
            swap(WordFrequency, other.WordFrequency);
            swap(DocumentFrequency, other.DocumentFrequency);
            swap(Postings, other.Postings);
            swap(IsAdd, other.IsAdd);
        }

        struct Schema;

    protected:
        void InitMetadata(const char*, const char*)
        {
        }
    };

    inline void swap(::XiaoyaStore::Model::PostingList& left, ::XiaoyaStore::Model::PostingList& right)
    {
        left.swap(right);
    }

    
    struct IndexKey
    {
        uint64_t UrlFileId;
        std::string Word;
        
        IndexKey()
          : UrlFileId()
        {
        }

        
#ifndef BOND_NO_CXX11_DEFAULTED_FUNCTIONS
        // Compiler generated copy ctor OK
        IndexKey(const IndexKey&) = default;
#endif
        
#if !defined(BOND_NO_CXX11_DEFAULTED_MOVE_CTOR)
        IndexKey(IndexKey&&) = default;
#elif !defined(BOND_NO_CXX11_RVALUE_REFERENCES)
        IndexKey(IndexKey&& other)
          : UrlFileId(std::move(other.UrlFileId)),
            Word(std::move(other.Word))
        {
        }
#endif
        
        
#ifndef BOND_NO_CXX11_DEFAULTED_FUNCTIONS
        // Compiler generated operator= OK
        IndexKey& operator=(const IndexKey&) = default;
#endif

        bool operator==(const IndexKey& other) const
        {
            return true
                && (UrlFileId == other.UrlFileId)
                && (Word == other.Word);
        }

        bool operator!=(const IndexKey& other) const
        {
            return !(*this == other);
        }

        void swap(IndexKey& other)
        {
            using std::swap;
            swap(UrlFileId, other.UrlFileId);
            swap(Word, other.Word);
        }

        struct Schema;

    protected:
        void InitMetadata(const char*, const char*)
        {
        }
    };

    inline void swap(::XiaoyaStore::Model::IndexKey& left, ::XiaoyaStore::Model::IndexKey& right)
    {
        left.swap(right);
    }

    
    struct Index
    {
        uint64_t IndexId;
        ::XiaoyaStore::Model::IndexKey Key;
        uint32_t WordFrequency;
        double Weight;
        uint32_t OccurencesInTitle;
        uint32_t OccurencesInLinks;
        uint32_t OccurencesInHeaders;
        std::list<uint32_t> Positions;
        
        Index()
          : IndexId(),
            WordFrequency(),
            Weight(),
            OccurencesInTitle(),
            OccurencesInLinks(),
            OccurencesInHeaders()
        {
        }

        
#ifndef BOND_NO_CXX11_DEFAULTED_FUNCTIONS
        // Compiler generated copy ctor OK
        Index(const Index&) = default;
#endif
        
#if !defined(BOND_NO_CXX11_DEFAULTED_MOVE_CTOR)
        Index(Index&&) = default;
#elif !defined(BOND_NO_CXX11_RVALUE_REFERENCES)
        Index(Index&& other)
          : IndexId(std::move(other.IndexId)),
            Key(std::move(other.Key)),
            WordFrequency(std::move(other.WordFrequency)),
            Weight(std::move(other.Weight)),
            OccurencesInTitle(std::move(other.OccurencesInTitle)),
            OccurencesInLinks(std::move(other.OccurencesInLinks)),
            OccurencesInHeaders(std::move(other.OccurencesInHeaders)),
            Positions(std::move(other.Positions))
        {
        }
#endif
        
        
#ifndef BOND_NO_CXX11_DEFAULTED_FUNCTIONS
        // Compiler generated operator= OK
        Index& operator=(const Index&) = default;
#endif

        bool operator==(const Index& other) const
        {
            return true
                && (IndexId == other.IndexId)
                && (Key == other.Key)
                && (WordFrequency == other.WordFrequency)
                && (Weight == other.Weight)
                && (OccurencesInTitle == other.OccurencesInTitle)
                && (OccurencesInLinks == other.OccurencesInLinks)
                && (OccurencesInHeaders == other.OccurencesInHeaders)
                && (Positions == other.Positions);
        }

        bool operator!=(const Index& other) const
        {
            return !(*this == other);
        }

        void swap(Index& other)
        {
            using std::swap;
            swap(IndexId, other.IndexId);
            swap(Key, other.Key);
            swap(WordFrequency, other.WordFrequency);
            swap(Weight, other.Weight);
            swap(OccurencesInTitle, other.OccurencesInTitle);
            swap(OccurencesInLinks, other.OccurencesInLinks);
            swap(OccurencesInHeaders, other.OccurencesInHeaders);
            swap(Positions, other.Positions);
        }

        struct Schema;

    protected:
        void InitMetadata(const char*, const char*)
        {
        }
    };

    inline void swap(::XiaoyaStore::Model::Index& left, ::XiaoyaStore::Model::Index& right)
    {
        left.swap(right);
    }

    
    struct UrlFile
    {
        uint64_t UrlFileId;
        std::string Url;
        std::string Title;
        std::string FilePath;
        std::string FileHash;
        std::string Content;
        std::string TextContent;
        std::string Charset;
        std::string MimeType;
        double PageRank;
        uint32_t InLinkCount;
        uint32_t InLinkTotalLength;
        uint32_t HeaderCount;
        uint32_t HeaderTotalLength;
        uint64_t PublishDate;
        uint64_t UpdateInterval;
        uint64_t UpdatedAt;
        uint64_t CreatedAt;
        
        UrlFile()
          : UrlFileId(0ULL),
            PageRank(),
            InLinkCount(),
            InLinkTotalLength(),
            HeaderCount(),
            HeaderTotalLength(),
            PublishDate(),
            UpdateInterval(),
            UpdatedAt(),
            CreatedAt()
        {
        }

        
#ifndef BOND_NO_CXX11_DEFAULTED_FUNCTIONS
        // Compiler generated copy ctor OK
        UrlFile(const UrlFile&) = default;
#endif
        
#if !defined(BOND_NO_CXX11_DEFAULTED_MOVE_CTOR)
        UrlFile(UrlFile&&) = default;
#elif !defined(BOND_NO_CXX11_RVALUE_REFERENCES)
        UrlFile(UrlFile&& other)
          : UrlFileId(std::move(other.UrlFileId)),
            Url(std::move(other.Url)),
            Title(std::move(other.Title)),
            FilePath(std::move(other.FilePath)),
            FileHash(std::move(other.FileHash)),
            Content(std::move(other.Content)),
            TextContent(std::move(other.TextContent)),
            Charset(std::move(other.Charset)),
            MimeType(std::move(other.MimeType)),
            PageRank(std::move(other.PageRank)),
            InLinkCount(std::move(other.InLinkCount)),
            InLinkTotalLength(std::move(other.InLinkTotalLength)),
            HeaderCount(std::move(other.HeaderCount)),
            HeaderTotalLength(std::move(other.HeaderTotalLength)),
            PublishDate(std::move(other.PublishDate)),
            UpdateInterval(std::move(other.UpdateInterval)),
            UpdatedAt(std::move(other.UpdatedAt)),
            CreatedAt(std::move(other.CreatedAt))
        {
        }
#endif
        
        
#ifndef BOND_NO_CXX11_DEFAULTED_FUNCTIONS
        // Compiler generated operator= OK
        UrlFile& operator=(const UrlFile&) = default;
#endif

        bool operator==(const UrlFile& other) const
        {
            return true
                && (UrlFileId == other.UrlFileId)
                && (Url == other.Url)
                && (Title == other.Title)
                && (FilePath == other.FilePath)
                && (FileHash == other.FileHash)
                && (Content == other.Content)
                && (TextContent == other.TextContent)
                && (Charset == other.Charset)
                && (MimeType == other.MimeType)
                && (PageRank == other.PageRank)
                && (InLinkCount == other.InLinkCount)
                && (InLinkTotalLength == other.InLinkTotalLength)
                && (HeaderCount == other.HeaderCount)
                && (HeaderTotalLength == other.HeaderTotalLength)
                && (PublishDate == other.PublishDate)
                && (UpdateInterval == other.UpdateInterval)
                && (UpdatedAt == other.UpdatedAt)
                && (CreatedAt == other.CreatedAt);
        }

        bool operator!=(const UrlFile& other) const
        {
            return !(*this == other);
        }

        void swap(UrlFile& other)
        {
            using std::swap;
            swap(UrlFileId, other.UrlFileId);
            swap(Url, other.Url);
            swap(Title, other.Title);
            swap(FilePath, other.FilePath);
            swap(FileHash, other.FileHash);
            swap(Content, other.Content);
            swap(TextContent, other.TextContent);
            swap(Charset, other.Charset);
            swap(MimeType, other.MimeType);
            swap(PageRank, other.PageRank);
            swap(InLinkCount, other.InLinkCount);
            swap(InLinkTotalLength, other.InLinkTotalLength);
            swap(HeaderCount, other.HeaderCount);
            swap(HeaderTotalLength, other.HeaderTotalLength);
            swap(PublishDate, other.PublishDate);
            swap(UpdateInterval, other.UpdateInterval);
            swap(UpdatedAt, other.UpdatedAt);
            swap(CreatedAt, other.CreatedAt);
        }

        struct Schema;

    protected:
        void InitMetadata(const char*, const char*)
        {
        }
    };

    inline void swap(::XiaoyaStore::Model::UrlFile& left, ::XiaoyaStore::Model::UrlFile& right)
    {
        left.swap(right);
    }

    
    struct Link
    {
        uint64_t LinkId;
        uint64_t UrlFileId;
        std::string Url;
        std::string Text;
        
        Link()
          : LinkId(),
            UrlFileId()
        {
        }

        
#ifndef BOND_NO_CXX11_DEFAULTED_FUNCTIONS
        // Compiler generated copy ctor OK
        Link(const Link&) = default;
#endif
        
#if !defined(BOND_NO_CXX11_DEFAULTED_MOVE_CTOR)
        Link(Link&&) = default;
#elif !defined(BOND_NO_CXX11_RVALUE_REFERENCES)
        Link(Link&& other)
          : LinkId(std::move(other.LinkId)),
            UrlFileId(std::move(other.UrlFileId)),
            Url(std::move(other.Url)),
            Text(std::move(other.Text))
        {
        }
#endif
        
        
#ifndef BOND_NO_CXX11_DEFAULTED_FUNCTIONS
        // Compiler generated operator= OK
        Link& operator=(const Link&) = default;
#endif

        bool operator==(const Link& other) const
        {
            return true
                && (LinkId == other.LinkId)
                && (UrlFileId == other.UrlFileId)
                && (Url == other.Url)
                && (Text == other.Text);
        }

        bool operator!=(const Link& other) const
        {
            return !(*this == other);
        }

        void swap(Link& other)
        {
            using std::swap;
            swap(LinkId, other.LinkId);
            swap(UrlFileId, other.UrlFileId);
            swap(Url, other.Url);
            swap(Text, other.Text);
        }

        struct Schema;

    protected:
        void InitMetadata(const char*, const char*)
        {
        }
    };

    inline void swap(::XiaoyaStore::Model::Link& left, ::XiaoyaStore::Model::Link& right)
    {
        left.swap(right);
    }

    
    struct IdList
    {
        std::set<uint64_t> Ids;
        bool IsAdd;
        
        IdList()
          : IsAdd(true)
        {
        }

        
#ifndef BOND_NO_CXX11_DEFAULTED_FUNCTIONS
        // Compiler generated copy ctor OK
        IdList(const IdList&) = default;
#endif
        
#if !defined(BOND_NO_CXX11_DEFAULTED_MOVE_CTOR)
        IdList(IdList&&) = default;
#elif !defined(BOND_NO_CXX11_RVALUE_REFERENCES)
        IdList(IdList&& other)
          : Ids(std::move(other.Ids)),
            IsAdd(std::move(other.IsAdd))
        {
        }
#endif
        
        
#ifndef BOND_NO_CXX11_DEFAULTED_FUNCTIONS
        // Compiler generated operator= OK
        IdList& operator=(const IdList&) = default;
#endif

        bool operator==(const IdList& other) const
        {
            return true
                && (Ids == other.Ids)
                && (IsAdd == other.IsAdd);
        }

        bool operator!=(const IdList& other) const
        {
            return !(*this == other);
        }

        void swap(IdList& other)
        {
            using std::swap;
            swap(Ids, other.Ids);
            swap(IsAdd, other.IsAdd);
        }

        struct Schema;

    protected:
        void InitMetadata(const char*, const char*)
        {
        }
    };

    inline void swap(::XiaoyaStore::Model::IdList& left, ::XiaoyaStore::Model::IdList& right)
    {
        left.swap(right);
    }
} // namespace Model
} // namespace XiaoyaStore

